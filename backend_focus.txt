# Alioth Backend MVP Implementation Focus
## Target: NestJS Backend as Orchestrator for Chainlink Hackathon Demo

### üéØ **Core Responsibility**
The backend acts as a **smart orchestrator** that coordinates between AI agent analysis and on-chain Chainlink execution, WITHOUT performing critical financial logic that bypasses on-chain validation.

## üìã **Required API Endpoints for MVP Demo**

### **1. POST /api/v1/ai-optimization/optimize-deposit**
```typescript
// Location: src/modules/ai-optimization/controllers/ai-optimization.controller.ts
@Post('optimize-deposit')
async optimizeDeposit(@Body() request: OptimizeDepositDto) {
  // 1. Validate user input
  // 2. Call AI Agent for analysis
  // 3. Prepare contract call parameters
  // 4. Submit to smart contract
  // 5. Return transaction hash and strategy
}

interface OptimizeDepositDto {
  userAddress: string;
  inputToken: string; // USDC address
  inputAmount: string; // "1000000000" (1000 USDC in wei)
  riskTolerance: 'conservative' | 'balanced' | 'aggressive';
  minYieldThreshold?: number;
}

interface OptimizationResponse {
  success: boolean;
  transactionHash: string;
  strategy: AllocationStrategy;
  estimatedAPY: number;
  reasoning: string;
  trackingId: string;
}
```

### **2. WebSocket Integration for Real-time Updates**
```typescript
// Location: src/modules/ai-optimization/gateways/optimization.gateway.ts
@WebSocketGateway(3001, { cors: true })
export class OptimizationGateway {
  // Real-time updates for:
  // - Contract execution status
  // - Chainlink automation triggers
  // - Portfolio performance updates
  // - Rebalancing events
}
```

## ü§ñ **AI Agent Integration Service**

### **Required: AgentCommunicationService**
```typescript
// Location: src/modules/ai-optimization/services/agent-communication.service.ts
@Injectable()
export class AgentCommunicationService {
  async requestYieldAnalysis(params: YieldAnalysisRequest): Promise<YieldAnalysisResponse> {
    // Call ElizaOS agent via HTTP/WebSocket
    // Parse AI recommendations
    // Validate response format
    // Return structured data for contract calls
  }
}

interface YieldAnalysisRequest {
  inputToken: string;
  inputAmount: string;
  currentMarketData: MarketData;
  userRiskProfile: RiskProfile;
}

interface YieldAnalysisResponse {
  allocation: {
    protocol: 'aave' | 'compound' | 'yearn';
    percentage: number;
    expectedAPY: number;
    riskScore: number;
  }[];
  confidence: number;
  reasoning: string;
  marketAnalysis: MarketAnalysis;
}
```

## üîó **Smart Contract Integration Service**

### **Required: Web3ContractService Enhancement**
```typescript
// Location: src/modules/ai-optimization/services/web3-contract.service.ts
@Injectable()
export class Web3ContractService {
  async executeOptimizedDeposit(strategy: AllocationStrategy): Promise<TransactionResult> {
    // 1. Prepare contract call data
    // 2. Estimate gas costs
    // 3. Call EnhancedYieldOptimizer.optimizeDeposit()
    // 4. Monitor transaction status
    // 5. Emit WebSocket updates
    // 6. Store execution log
  }

  async listenToChainlinkEvents(): Promise<void> {
    // Listen for:
    // - YieldOptimized events
    // - AutomationRegistered events
    // - RebalanceExecuted events
    // - PriceValidated events
  }
}
```

## üìä **Market Data Service**

### **Required: ChainlinkDataService**
```typescript
// Location: src/modules/market-analysis/services/chainlink-data.service.ts
@Injectable()
export class ChainlinkDataService {
  async getCurrentMarketData(tokens: string[]): Promise<MarketData> {
    // Fetch data for AI agent analysis (NOT for contract decisions)
    // Include: prices, yields, volatility, correlations
    // Source: Multiple APIs + Chainlink feeds for reference
  }

  async getProtocolYields(): Promise<ProtocolYields> {
    // Aave, Compound, Yearn current APYs
    // For AI recommendation only
    // Smart contract will validate actual rates
  }
}
```

## üèóÔ∏è **Database Schema Requirements**

### **1. Optimization Executions Collection**
```typescript
// Location: src/shared/database/schemas/optimization-execution.schema.ts
@Schema({ timestamps: true })
export class OptimizationExecution {
  @Prop({ required: true })
  userAddress: string;

  @Prop({ required: true })
  inputToken: string;

  @Prop({ required: true })
  inputAmount: string;

  @Prop({ required: true })
  strategy: AllocationStrategy;

  @Prop({ required: true })
  transactionHash: string;

  @Prop({ required: true })
  status: 'pending' | 'executed' | 'failed';

  @Prop()
  chainlinkAutomationId?: string;

  @Prop()
  aiRecommendation: YieldAnalysisResponse;

  @Prop()
  actualPerformance?: PerformanceMetrics;
}
```

### **2. Chainlink Events Collection**
```typescript
// Location: src/shared/database/schemas/chainlink-event.schema.ts
@Schema({ timestamps: true })
export class ChainlinkEvent {
  @Prop({ required: true })
  eventType: 'price_validation' | 'automation_trigger' | 'upkeep_performed';

  @Prop({ required: true })
  transactionHash: string;

  @Prop({ required: true })
  blockNumber: number;

  @Prop()
  optimizationId: string;

  @Prop()
  eventData: Record<string, any>;
}
```

## üîß **Environment Configuration**

### **Required Environment Variables**
```bash
# Smart Contract Configuration
ENHANCED_YIELD_OPTIMIZER_ADDRESS=0x...
CHAINLINK_FEED_MANAGER_ADDRESS=0x...

# AI Agent Configuration
AI_AGENT_ENDPOINT=http://localhost:3002
AI_AGENT_API_KEY=...

# Blockchain Configuration
WEB3_RPC_URL=...
PRIVATE_KEY=... # For contract interaction
CHAIN_ID=11155111 # Sepolia testnet

# Chainlink Configuration
CHAINLINK_VRF_SUBSCRIPTION_ID=...
CHAINLINK_AUTOMATION_REGISTRY=...
```

## üö¶ **Implementation Priority Order**

### **Phase 1: Core Orchestration** (MVP Essential)
1. ‚úÖ OptimizeDepositDto validation and controller
2. ‚úÖ AgentCommunicationService with HTTP client
3. ‚úÖ Web3ContractService with optimizeDeposit() call
4. ‚úÖ Basic error handling and logging
5. ‚úÖ Database schema and persistence

### **Phase 2: Real-time Features** (Demo Enhancement)
1. ‚úÖ WebSocket gateway for live updates
2. ‚úÖ Chainlink event listeners
3. ‚úÖ Performance tracking and metrics
4. ‚úÖ Advanced error recovery

### **Phase 3: Production Features** (Post-MVP)
1. ‚è≥ Comprehensive rate limiting
2. ‚è≥ Advanced caching strategies
3. ‚è≥ Multi-chain support
4. ‚è≥ Advanced monitoring and alerting

## üß™ **Testing Requirements**

### **Critical Test Cases**
```typescript
// Location: src/modules/ai-optimization/ai-optimization.controller.spec.ts
describe('AI Optimization Controller', () => {
  it('should orchestrate full optimization flow', async () => {
    // 1. Mock AI agent response
    // 2. Mock smart contract interaction
    // 3. Verify orchestration logic
    // 4. Assert no critical validation bypass
  });

  it('should handle AI agent failures gracefully', async () => {
    // Test fallback mechanisms
  });

  it('should validate all inputs before contract calls', async () => {
    // Ensure no malicious inputs reach contracts
  });
});
```

## üìã **Success Criteria for MVP Demo**

### **Must Work Flawlessly:**
1. ‚úÖ User deposits 1000 USDC ‚Üí Backend receives request
2. ‚úÖ Backend calls AI agent ‚Üí Receives allocation recommendation
3. ‚úÖ Backend formats data ‚Üí Calls smart contract successfully
4. ‚úÖ Backend listens for events ‚Üí Updates user via WebSocket
5. ‚úÖ Chainlink automation triggers ‚Üí Backend tracks rebalancing

### **Demo Script Integration:**
```typescript
// Demo endpoint for consistent testing
@Get('demo/status/:trackingId')
async getDemoStatus(@Param('trackingId') trackingId: string) {
  return {
    stage: 'optimization_executed' | 'automation_registered' | 'rebalance_triggered',
    chainlinkEvents: ChainlinkEvent[],
    currentPerformance: PerformanceMetrics,
    nextRebalanceEstimate: Date
  };
}
```

## üéØ **Key Implementation Notes**

1. **NO Financial Logic in Backend** - All critical decisions happen on-chain
2. **Pure Orchestration** - Backend only coordinates between components
3. **Chainlink Validation** - All price/rate validations happen on-chain via Chainlink
4. **Event-Driven Updates** - Use blockchain events for state updates
5. **Graceful Failures** - Handle AI agent or contract failures elegantly
6. **Comprehensive Logging** - Track every step for demo and debugging 